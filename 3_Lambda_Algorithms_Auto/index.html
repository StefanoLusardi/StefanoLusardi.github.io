<!doctype html>
<html lang="en">
	<head>
		<meta charset="utf-8">
		<title>Modern C++: 3. STL Algorithms, Lambda Expressions and auto</title>
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
		<link rel="stylesheet" href="../reveal.js-3.6.0/css/reveal.css">
		<link rel="stylesheet" href="../reveal.js-3.6.0/css/theme/dark.css" id="theme">
		<link rel="stylesheet" href="../reveal.js-3.6.0/lib/css/zendark.css">
	</head>
	<body>
		<div class="reveal">
			<div class="slides">
				<!-- Modern C++ -->
				<section>
					<h2>Modern C++ <br>
						Standard Practices from Standard Library</h2>
				    <br>
					<h3 id="c1">3. STL Algorithms and Lambda Expressions</h3>
					<br>
					<p>
						<small>Stefano Lusardi, Software Developer</small>
					</p>
				</section>				
				
				<!-- Agenda -->
				<section>
					<h3 id="c1">Agenda</h3>
					<br>
					<p><ul>						
						<li>Smart Pointers ( Ownership ) </li>						
						<li>Move Semantics ( <i>lvalue</i> vs. <i>rvalue</i> ) </li>
					</ul></p>
				</section>					
				

	Examples: for_each (non-mutating) vs. transform (mutating), partition + rotate, distance(iterator) + find(in range)
	C++17 introduces Execution Policies (sequential, parallel, ...)

				<!-- std::algorithms -->
				<section>	
					<h3>std::algorithms</h3>
					<br>	
					<section>
						<p>What is an std::algorithm?</p>
						<br>	
						<p>It is a functions designed to address <span id="c1">general purpose</span> problems 
							that can be used on a <span id="c1">range</span> of elements.</p>
						<p>Since the STL is just all about Containers, Iterators and Algorithms 
							it is designed to have the best possible interaction between these components</p>
						<br>
						<p>See the full reference at: https://en.cppreference.com/w/cpp/algorithm</p>	
					</section>
					
					<section>
						<p>Why do we need an Algorithm <small>(in Modern C++)</small> ?</p>
						<br>
						<p><span id="c1">Expressive, Solid, and Reusable</span> chunks of code.</p>
						<br>
						<p>Do you remember the initial example given in the first talk?</p>	
					</section>

					<section>
						<br>					
						<p><pre><code class="cpp" data-trim contenteditable>
// 1. "Raw" for loop
int c = 0;
for (int i = 0; i &lt; myVec.size(); ++i) {
    myVec[i] == 5 && ++c;
}
						</code></pre></p>						
						<br>
						<p><pre><code class="cpp" data-trim contenteditable>
// 2. Modern algorithm
int c = std::count(begin(myVec), end(myVec), 5);
						</code></pre></p>
						<br>
					</section>

					<section>
						<p>A brief recap/comparison:</p>
						<br>
						<p>
							1. Cons:
							<ul>
								<li>Hand-made for loop <small>(How many time did you mess up with loop indexes?)</small></li>
								<li>Not immediately clear logic</li>
							</ul>

							2. Pros:
							<ul>
								<li>Automatic loop unrolling <small>(No more worries about indexes!)</small></li>
								<li>Easy to understand logic</li>
							</ul>
						</p>
					</section>

					<section>
						<p>How does an algorithm work?</p>
						<p>The algorithm is applied on a given container <span id="c1">range</span>, typically defined as: <i>first</i>, <i>last</i>.</p>
						<p>According to the specific algorithm we are using we can have (or we can't have) several guarantees such as: 
						<br>Modifying, Non-Modifying, Searching, Sorting... </p>
						<br>
						<p>Usually the pair [begin() end()] iterators are used to define the sequence range, 
							but there is no restriction set on the input range.</p>	
					</section>

					<section>
						<p>Iterators range. Any differences?</p>
						<p><pre><code class="cpp" data-trim contenteditable>
int c = std::count(begin(myVec), end(myVec), 5);
						</code></pre></p>
						<br>
						<p><pre><code class="cpp" data-trim contenteditable>
int c = std::count(myVec.begin(), myVec.end(), 5);
						</code></pre></p>
						<br>
						<small>The first examplese uses free functions while the second uses member fucntions.</small>	
						<small>Note that the second example cannot work with C-style arrays, while the first is also able to accomodate them.</small>	
					</section>

					<section>
						<p>Single responsability principle</p>
						<p>Note that even if algorithms and lambdas are an extreme powerful resource 
							it is always better not to increase the code complexity and readability creating extremely complicated and nested logics.</p>
						<br>
						<p>Function still serves as functions!</p>
						<br>
						
					</section>


					<section>
						<p>std::algorithm with a predicate</p>
						<small></small>
						<br>
						<p>Example: std::find_if</p>	
						<p><pre><code class="cpp" data-trim contenteditable>
int f = std::find_if(myVec.begin(), myVec.end(), /* predicate */);
						</code></pre></p>
					</section>

					<section>
						<p>A predicate can be a so-called <i>Functor</i> (before C++11) or a <i>Lambda Function</i></p>
						<p>Example: std::find_if (continued)</p>
						<br>
						<p><pre><code class="cpp" data-trim contenteditable>
int f = std::find_if(myVec.begin(), myVec.end(), [](const Foo& foo){ return foo.value == 42; });
						</code></pre></p>	
					</section>
				</section>


				<!-- Lambda Functions -->
				<section>	
					<h3>Lambda Functions</h3>
					<section>
						<p>What is a Lambda Function?</p>
						<small></small>
						<br>
						<p>A Lambda Function is an <span id="c1">unnamed</span> and <span id="c1">callable</span> 
							object able to capture variables from an enclosing scope.</p>	
					</section>
					
					<section>
						<p>Anatomy of a Lambda Function</p>
						<p>
							<ol>
								<li><span id="c1">Capture Group</span></li>
								<li><span id="c1">Body</span></li>
								<li><small>(optional)</small><span id="c1">Parameters</span></li>
								<li><small>(optional)</small><span id="c1">Return type</span></li>
							</ol>							
						</p>
						<br>
						The Return Type can be automatically deduced
						<br>
						<p>
								- Lambdas. Can unnamed things be more expressive?
								Where to use them? Do you remember std::algorithms? example
								Now stop messing around with pointers to functions.
						</p>	
					</section>

					<section>
						<p>Anatomy of a std::function object</p>
						<br>
						<p>std::function<R(Params...)></p>
						<p>
							<ul>
								<li>R: return type of the wrapped function.</li>
								<li><small>(optional) </small>Params: types of input parameters</li>
							</ul>
						</p>
						<p>Example: </p>
						<br>
						<p><pre><code class="cpp" data-trim contenteditable>
void freeFunc(int i, std::string s, double d) { /*...*/ }; 
std::function<void(int, std::string, double)> freeFunc = freeFunc;
								
class Foo { 
    void func(double d) { /*...*/ }; 
}
std::function<void(const Foo& foo, double)> fooFunc = &Foo::func();
						</code></pre></p>
					</section>

					<section>
						<p>Function objects and Lambdas</p>
							<br>
							<p>std::function<T(Args...)> is a generic templated function wrapper. It can be used to store a Lambda Function as:</p>	
							<p><pre><code class="cpp" data-trim contenteditable>
// Declaration:
std::function<void(int)> myPrint = [](int val) -> void { std::cout << "Printed value: " << val; };

// Usage:
myPrint(42); // "Printed value: 42"
							</code></pre></p>
					</section>

					<section>
						<p>A more functional style</p>
						<br>
						<p>Lambdas and functions objects enables a more functional approach to the Modern C++:</p>
						<p>Using these tools it is now possible to declare a function in a local scope 
							(i.e. inside another function) and use it at any time in the enclosing scope</p>
						<br>
						<p>std::function<T(Args...)> is a generic templated function wrapper. It can be used to store a Lambda Function as:</p>	
						<p><pre><code class="cpp" data-trim contenteditable>
// Declaration:
std::function<void(int)> myPrint = [](int val) -> void { std::cout << "Printed value: " << val; };

// Usage:
myPrint(42); // "Printed value: 42"
						</code></pre></p>
					</section>					

					<section>
						<p>Declare and invoke</p>
						<br>
						<p>Lambdas can be declared and invoked directly in-place as:</p>
						<p><pre><code class="cpp" data-trim contenteditable>
// Declaration and immediate usage:
[](int val) -> void { 
    std::cout << "Printed value: " << val; 
}(42); // "Printed value: 42"
						</code></pre></p>
					</section>

					<section>
						<p>Embrace more complex <i>const correctness</i></p>
						<br>
						<p><pre><code class="cpp" data-trim contenteditable>
bool something = ...
const int myVal;
if (something) {
	myVal = 42;
} else {
    myVal = 0;
}
// This will not compile since myVal is
// declared const but not initialized
						</code></pre></p>
					</section>

					<section>
						<p>When the ternary operator (condition ? a : b) is not enough</p>
						<br>
						<p><pre><code class="cpp" data-trim contenteditable>
bool something = ...
const int myVal = [something]() -> int {
	if (something) { return 42; } 
	return 0;
}();
						</code></pre></p>
						<small>The if-else logic is embedded in a lambda immediately invoked after its declaration.	
							This allows to set the const int according to the desired condition.</small>
					</section>

				</section>

				<!-- auto -->
				<section>	
					<h3>auto</h3>
					<section>
						<p></p>
						<small></small>
						<br>
						<p>
							<span id="c1"></span>
							<br>
						</p>	
					</section>
					
					<section>
						<p>Example on trailing return type (using decltype(x))</p>
						<small></small>
						<br>
						<p>
							<span id="c1"></span>
							<br>
						</p>	
					</section>
				</section>

				<!-- Thank you! -->
				<section>	
					<h3>Thank you!</h3>
				</section>	
				
				<!-- What's next? -->
				<section>	
					<h3>What's next?</h3>
					<br>
					<h4>C++17 new features</h4>
				</section>	
				
				<!-- Questions? -->
				<section>	
					<h3>Questions?</h3>
				</section>	
				
				</section>
			</div>
		</div>

		<script src="../reveal.js-3.6.0/lib/js/head.min.js"></script>
		<script src="../reveal.js-3.6.0/js/reveal.js"></script>

		<script>
			Reveal.initialize({
				controls: true,
				progress: true,
				history: true,
				center: true,
				transition: 'slide', 
				dependencies: [
					{ src: '../reveal.js-3.6.0/lib/js/classList.js', condition: function() { return !document.body.classList; } },
					{ src: '../reveal.js-3.6.0/plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: '../reveal.js-3.6.0/plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: '../reveal.js-3.6.0/plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
					{ src: '../reveal.js-3.6.0/plugin/search/search.js', async: true },
					{ src: '../reveal.js-3.6.0/plugin/zoom-js/zoom.js', async: true },
					{ src: '../reveal.js-3.6.0/plugin/notes/notes.js', async: true }
				]
			});
		</script>

	</body>
</html>
