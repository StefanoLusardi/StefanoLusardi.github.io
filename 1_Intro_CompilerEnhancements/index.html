<!doctype html>
<html lang="en">
	<head>
		<meta charset="utf-8">
		<title>Modern C++: 1. Introduction, Standards and Compiler Enhancements</title>
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
		<link rel="stylesheet" href="../reveal.js-3.6.0/css/reveal.css">
		<link rel="stylesheet" href="../reveal.js-3.6.0/css/theme/dark.css" id="theme">
		<link rel="stylesheet" href="../reveal.js-3.6.0/lib/css/zendark.css">
	</head>
	<body>
		<div class="reveal">
			<div class="slides">
			
				<!-- Modern C++ -->
				<section>
					<h2>Modern C++ <br>
						Standard Practices from Standard Library</h2>
				    <br>
					<h3 id="c1">1. Course Introduction and Compiler Enhancements</h3>
					<br>
					<p>
						<small>Stefano Lusardi, Software Developer</small>
					</p>
				</section>
				
				<!-- Course introduction -->
				<section>
					<h3>Course introduction</h3>
					<br>
					<p><ul>
						<li>Self contained modules: no dependencies</li>
						<li>Practical focus: Code samples</li>
						<li>C++ devs: share, update, get in touch</li>
						<li>Non-C++ devs: insights and feature discovery</li>
					</ul></p>
				</section>
				
				<!-- Modern C++ Practices -->
				<section>				
					<h3>Modern C++ Practices</h3>
					<br>
					<p align="left">
						<span id="c1">Modern: </span>C++11 Standard and beyond
						<br>
						<span id="c1">Practices: </span>readable, expressive, solid, reusable pieces of code
					</p>
					<p><ul>
						<li>expressive: self-explicative </li>
						<li>solid: widely tested</li>
						<li>reusable: D.R.Y. (Don't Repeat Yourself)</li>
					</ul></p>
					<br>
					e.g.: std::count. Holds all the 3 principles
				</section>
				
				<!-- Standards -->
				<section>		
					<h3>Standards</h3>	
					<section>
					<br>
						<p><ul>
							<p>
								<li>What is a standard (library)?</li>
								<span id="c1"> Containers, Iterators, Algorithms</span>
							</p>
							<p>
								<li>Why do we need to have new standards?</li>
								<span id="c1"> General purpose</span>
							</p>
						</ul></p>
						<p>We will discuss only <span id="c1">STL</span> although Boost, Qt and others third party provides even wider set of features</p>
					</section>
					
					<section>
					<br>
						<p>The simplest example: loop comparison</p>
						<br>
						<p>Non-standard vs. standard implementation in practice</p>
						<br>
						<p>Remember that we are looking for:
							<ul>
								<li><span id="c1">Expressivity: </span>clear meaning, easy to understand</li>
								<li><span id="c1">Testability: </span>easy to test, or better, already tested</li>
								<li><span id="c1">Reusability: </span>have room for new features on top</li>
							</ul>
						</p>
					</section>
					
					<section>
						<br>
						<p>Example: <span id="c1">"Old school"</span> for loop</p>						
						<p><pre><code class="cpp" data-trim contenteditable>
int c = 0;
for (int i = 0; i &lt; myVec.size(); ++i) {
    myVec[i] == 5 && ++c;
}
						</code></pre></p>
						<p>How many times have you seen something like this (but ten times more complex)?</p>
						<p>To fully understand this snippet you need at least to read it once entirely</p>
					</section>
					
					<section>
						<br>
						<p>Example: <span id="c1">"New school"</span> standard algorithm</p>
						<br>
						<p><pre><code class="cpp" data-trim contenteditable>
int c = std::count(begin(myVec), end(myVec), 5);
						</code></pre></p>
						<br>
						<p>Isn't it clearer, shorter, more expressive and bullet proof?</p>
						<p><small>You can understand its meaning even without read it entirely!</small></p>
					</section>
						
				</section>	

				<!-- Modern Compiler -->
				<section>	
				<h3>Modern Compiler</h3>
					<section>
					<br>
						<p>What does your (modern) compiler do for you?</p>
					</section>
				</section>
				
				<section>	
				<h3>Modern Compiler</h3>
					<section>
					<br>
						<p>Automatic generation of 
							<a href="https://en.wikipedia.org/wiki/Special_member_functions" id="c1">
								<u>Special Member Functions</u>
							</a>
						</p>
						<p><ol>
							<li><span id="c1">Default Constructor</span> (only if no constructor generated by the user*)</li>
							<li><span id="c1">Destructor</span></li>
							<li><span id="c1">Copy Constructor</span> (if no user defined 5, 6)</li>
							<li><span id="c1">Copy Assignment</span> (if no user defined 5, 6)</li>							
							<li><span id="c1">Move Constructor</span> (if no user defined 2, 3, 4, 6)</li>
							<li><span id="c1">Move Assignment</span> (if no user defined 2, 3, 4, 5)</li>
						</ol></p>
						<small>*Note that even copy constructor counts as user generated</small>
					</section>
					
					<section>
						<p>All Special Member Functions</p>
						<p><pre><code class="cpp" data-trim contenteditable>
class Foo{
	Foo();                      // 1. Default Constructor
	~Foo();                     // 2. Destructor
	Foo(const Foo&);            // 3. Copy Constructor
	Foo& operator=(const Foo&); // 4. Copy Assignment
	Foo(Foo&&);                 // 5. Move Constructor
	Foo& operator=(Foo&&);      // 6. Move Assignment
};
						</code></pre></p>
					</section>
					
					<section>
						<p>Partial Special Member Functions</p>
						<p><pre><code class="cpp" data-trim contenteditable>
// What you write:
class Bar {
    Bar(const Bar& bar, int i = 0);
    // This counts as user defined copy constructor since 
    // the second argument is defaulted
};
// What you get:
class Bar {
    //1. No Default Constructor: we have a user defined ctor
    ~Bar();                     // 2. Destructor
    Bar(const Bar&);            // 3. Copy Constructor
    Bar& operator=(const Bar&); // 4. Copy Assignment
    // 5. No Move Constructor: we have a user defined copy ctor
    // 6. No Move Assignment: we have a user defined copy ctor
};
						</code></pre></p>
					</section>
					
					<section>
					<br>
						<h4>Hard to remember uh?</h4> 
						<p>Use the <span id="c1">Rule of 3 (or 5)</span>:</p>
						<p>"If a class requires a user-defined destructor, a user-defined copy constructor, or a user-defined copy assignment operator, it almost certainly requires all three."</p>
						
						<p><small>from  
							<a href="https://en.cppreference.com/w/cpp/language/rule_of_three" id="c1">
								<u>cppreference.com</u>
							</a>
						</small></p>
						
						<br>
						<small>Note that in case you want to have deep copy instead of shallow copy you must anyway implement your own copies</small>
					</section>
				</section>	
				
				<section>	
				<h3>Modern Compiler</h3>
					<section>
						<p><span id="c1">default</span> and <span id="c1">delete</span> specifiers</p>
						<br>
						<p><ul>
							<li>Defaulted function counts as a user defined function</li>
							<li>Deleted function counts as a user defined function</li>
						</ul></p>
					</section>
					
					<section>
						<br>
						<p><pre><code class="cpp" data-trim contenteditable>	
struct Foo{
    Foo(double radius) { }
    Foo(Foo& c) = delete;
    Foo& operator=(Foo& c) = delete;
};

int main(){
    Foo f1;      // KO: No default ctor
    Foo f2(2);   // -OK-
    f2 = f2;     // KO: No copy assignament
    Foo f3(f2);  // KO: No copy ctor
    Foo f4 = f2; // KO: No copy ctor
    return 0;
}
						</code></pre></p>
						<p>Do you still need a private copy ctor/assignment? 
						<br>
						No, just delete them!</p>
					</section>
				</section>				
				
				<section>	
				<h3>Modern Compiler</h3>
					<section>
						<p><span id="c1">Explicit</span> constructor specifier</p>
						<p><pre><code class="cpp" data-trim contenteditable>	
struct Circle{
    // Not Explicit ctor
    Circle(double radius) : mRadius{radius} { }
    double Area() const { return mRadius * mRadius * PI; }
    double mRadius;
};	

struct Square{
    // Explicit ctor
    explicit Square(double side) : mSide{side} { }
    double Area() const { return mSide * mSide; }
    double mSide;
};
						</code></pre></p>
					</section>
				
					<section>
					<br>
						<p><pre><code class="cpp" data-trim contenteditable>
double Area(Circle c){ return c.Area(); }

double Area(Square s){ return s.Area(); }

int main(){
    Circle c(4);
    Square s(4);
    
    std::cout << "Circle Area: " << Area(c) << "\n";
    std::cout << "Square Area: " << Area(s) << "\n";
    std::cout << "Which Area?: " << Area(4) << "\n";
    
    return 0;
}
						</code></pre></p>
					</section>					
				</section>
				
				<section>	
				<h3>Modern Compiler</h3>
					<section>
						<p><span id="c1">RVO</span> (Return Value Optimization)</b>
						<br>
						<p>Generating useless copies: why do we care? </b>
					</section>
					
					<section>
						<br>
						<p>
							<small>g++ -std=c++11 -fno-elide-constructors -O2 -pedantic -pthread main.cpp && ./a.out</small>
							<small>example on   
								<a href="http://coliru.stacked-crooked.com/" id="c1">
									<u>coliru.com</u>
								</a>
							</small>
						</p>
						
						<p><pre><code class="cpp" data-trim contenteditable>
struct C {
  C() {}
  C(const C&) { std::cout << "A copy was made.\n"; }
};

C f() {
  return C();
}

int main() {
  C c = f();
}
						</code></pre></p>
						<br>
						<small>Note that Move Semantics will be treated in depth in the next talk</small>					
					</section>
				</section>	
				
				<!-- Thank you! -->
				<section>	
					<h3>Thank you!</h3>
				</section>	
				
				<!-- What's next? -->
				<section>	
					<h3>What's next?</h3>
					<br>
					<h4>Move Semantics and Smart Pointers</h4>
				</section>	
				
				<!-- Questions? -->
				<section>	
					<h3>Questions?</h3>
				</section>	
				
				</section>
			</div>
		</div>

		<script src="../reveal.js-3.6.0/lib/js/head.min.js"></script>
		<script src="../reveal.js-3.6.0/js/reveal.js"></script>

		<script>
			Reveal.initialize({
				controls: true,
				progress: true,
				history: true,
				center: true,
				transition: 'slide', 
				dependencies: [
					{ src: '../reveal.js-3.6.0/lib/js/classList.js', condition: function() { return !document.body.classList; } },
					{ src: '../reveal.js-3.6.0/plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: '../reveal.js-3.6.0/plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: '../reveal.js-3.6.0/plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
					{ src: '../reveal.js-3.6.0/plugin/search/search.js', async: true },
					{ src: '../reveal.js-3.6.0/plugin/zoom-js/zoom.js', async: true },
					{ src: '../reveal.js-3.6.0/plugin/notes/notes.js', async: true }
				]
			});
		</script>

	</body>
</html>
